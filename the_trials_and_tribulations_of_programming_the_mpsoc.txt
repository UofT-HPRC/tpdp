One does not simply upload a bitstream.

The steps to reprogramming the MPSoC are frustratingly convoluted, and depend
on many things being in place. This file is meant to help you deal with that.

Still though: prepare for great pain and suffering.

TL;DR
-----

The list of commands I end up using:

-> On my computer
$ bootgen -arch zynqmp -image specific.bif -o my_output.bin -w
$ dtc -O dtb -o my_output.dtbo -b 0 -@ my_thing.dtsi
$ scp ...

-> On the MPSoC
$ sudo insmod /path/to/axidma.ko
$ cp my.bin /lib/firmware/whateveriputinthedevicetree.bin
$ cp my.dtbo /lib/firmware/my.dtbo
$ set_clocks freq1 [freq2] [freq3] [freq4] 
$ cd /lib/firmware
$ overlay_reprogram my.dtbo

OVERVIEW 
--------

First, you need to make sure your MPSoC is running Linux in the exact way Clark
set it up. From now on, I will make this assumption. I do not know how to get
this system working, but I do know it includes:
 - The special drivers that let you apply device tree overlays
 - The special drivers that allow the kernel to reprorgam the FPGA (something
   to do with PCAP)
 - The special drivers used for setting the PS's output clocks
 - The XVC server needed to access ILAs from a remote copmuter
 - I also think there are some special drivers for dealing with other low-level
   mpsoc stuff, but I don't know what they do

And if you plan to use the PS to PL communication...
 - Xilinx's "driver" for AXI DMA cores (note: internally, Linux uses something
   called the DMAEngine API. This "driver" does not actually make any device
   files; it only extends the capabilities of the DMAEngine API, which other 
   drivers can use)
 - axidma.ko: a special driver that uses the kernel's internal DMAEngine API
   and makes device files you can access from userspace. (This is explained in
   detail in the "PS to PL" stuff). This was not made by Xilinx; instead, it
   was made by Brandon Perez and Jared Choi. It is extremely good, and these
   guys actually documented a lot of the arcane wizardry needed to use the
   Xilinx driver
 - Some usermode libraries that make it "easier" to interface with the axidma
   library (which is itself making it possible to use Xilinx's AXI DMA driver)

Programming the FPGA requires a .bin file and a .dtbo file. The .bin file
instructions are in the next section, and the .dtbo instructions are in the
"Device Tree Acrobatics" section.

Once you have these two files, you need to jump through several complicated
hoops to get your bitstream programmed in the actual FPGA fabric. These are
detailed in the "Actually programming the FPGA" section.

With any luck you'll get the bitstream uploaded, but you're still not done! If
you want to use ILAs, or you want to write code that communicates to your
design, there are a million more things for you to do, and I've tried to point
out a few things in the sections at the end of this document.

No, there is no easier way.

GETTING THE .BIN FILE 
---------------------

I don't really know why we need a .bin instead of a .bit; I only know that the
code in the Linux kernel needs the bitstream to be in a ".bin" format in order
to reprogram the FPGA.

Anyway, making the .bin file just takes a single command: (Make sure to source
the settings64.sh shell script in your Vivado install)

$ bootgen -arch zynqmp -image specific.bif -o my_output.bin -w

The annoying thing is that this bootgen command is used for a lot of things,
and every time you use it you need to give it a special file with special
syntax that tells it what to do. In the case of simply making a .bin, the
specific.bif file you need is as follows:

<specific.bif> 
all: 
{ 
	[destination_device = pl] my_bitstream.bit 
}
</specific.bif>

Make sure my_bitstream.bit is in the same folder as the specific.bif file.



DEVICE TREE ACROBATICS 
----------------------

You also need to make a "device tree overlay". This involves writing a file in
a special language, then compiling it to a special binary file the Linux kernel
will understand. Writing the overlay is EXTREMELY DIFFICULT; I have done my
best to explain what I know about it. Compiling the file is easy, but you need
to have the device tree compiler installed. Most Linux distributions have a
"dtc" package in their official repos.

-> Background on device trees and device tree overlays

"Device trees" is the name given to a technique introduced by OpenFirmware.
Essentially, you give the Linux kernel a file (called a device tree) with a
bunch of information about the hardware in your embedded system. Normally, for
regular embedded systems, this file is created once and placed somewhere where
the kernel will read it at boot time. This assumes the hardware doesn't change
at runtime.

However, if you are reprogramming an FPGA, then the hardware _is_ changing at
runtime. It would be a pain in the rear end to reboot the Linux kernel every
time, so there's another technique called "device tree overlays". Basically,
you write a .dtsi file and copmile it to a .dtbo file. Then, using a special
driver that Clark has included with the Linux system, you ask the Linux kernel
to read in this .dtbo file and essentially "patch" the device tree data it is
already using. This has the potential to trigger several actions inside the
Linux kernel (for example, notifying drivers about hardware changes, and we
also use it to program the FPGA).

Something you should know: the whole device tree method is still immature. The
overlay method is essentially still in beta. People are working on it, but it's
a huge and complicated thing that touches a lot of kernel code, so it's slow
progress.

-> Writing the device tree overlay

The syntax for device trees is already bad, but the syntax for overlays is far,
far worse. At this point, I will encourage you to give up understanding it. For
starters, unless you wrote your own driver, there is LITERALLY NO WAY for you
to figure out how to write device tree entries for it (the driver writer must
provide this info to you). Also, the syntax is very likely to change several
times in the next few years, so there's really no point learning it until it's
more stable.

Our device tree overlay has to accomplish four jobs:

1) Upload the bitstream (in the .bin format) to the FPGA 
2) Set the frequency of the PS's output clocks in the PL (i.e. the ones you set 
   on the Zynq block in your block diagram).  
3) (If using PS to PL) Tell Xilinx's DMA driver about AXI DMA cores in your 
   design.  
4) (If using PS to PL) Tell the axidma driver about the AXI DMA cores in your 
   design

The general format of the dtsi file is something like:

	/dts-v1/;
	/plugin/;
	/ {
		fragment@0 {
			target = <&some_target>;
			overlay0: __overlay__ {
				/* Specific stuff for some_target */
			};
		};

		fragment@1 {
			target = <&some_other_target>;
			overlay0: __overlay__ {
				/* Specific stuff for some_other_target */
			};
		};

		/* etc... */
	};

Each one of the four jobs we need to do is performed in a separate "fragment
and overlay" block.

-> Jobs 1 and 2

Luckily, these aren't too difficult. LEAVE EVERYTHING AS-IS, except the 
reference to your bitstream and the clock frequencies

	fragment@0 {
		target = <&fpga_full>;
		overlay0: __overlay__ {
			#address-cells = <2>;
			#size-cells = <2>;
			firmware-name = "my_bistream.bin";
			resets = <&rst 116>;
		};
	};
	fragment@1 {
		target = <&fclk0>;
		overlay1: __overlay__ {
			status = "okay";
			#clock-cells = <0>;
			clock-frequency = <99999001>;
			compatible = "fixed-clock";
		};
	};

I don't know this for sure, but if you have more than one output clock, you
need to put them in separate fragment blocks. Make sure to increase the
fragment and overlay indices as you go.

-> Job 3 (Informing Xilinx's driver about AXI DMA cores)

This is by far the most hideous thing I've ever seen. Here is the code I've been using:

	fragment@2 {
		target = <&amba>;
		overlay2: __overlay__ {
			axi_dma_0: dma@a0030000 {
				#dma-cells = <1>;
				clock-names = "s_axi_lite_aclk", "m_axi_sg_aclk", "m_axi_mm2s_aclk", "m_axi_s2mm_aclk";
				clocks = <&fclk0>, <&fclk0>, <&fclk0>, <&fclk0>;
				compatible = "xlnx,axi-dma-1.00.a";
				interrupt-names = "mm2s_introut", "s2mm_introut";
				interrupt-parent = <&gic>;
				interrupts = <0 89 4 0 90 4>;
				reg = <0x0 0xa0030000 0x0 0x10000>;
				xlnx,addrwidth = <0x40>;
				xlnx,include-sg ;
				dma-channel@a0030000 {
					compatible = "xlnx,axi-dma-mm2s-channel";
					dma-channels = <0x1>;
					interrupts = <0 89 4>;
					xlnx,datawidth = <0x80>;
					xlnx,device-id = <0x0>;
				};
				dma-channel@a0030030 {
					compatible = "xlnx,axi-dma-s2mm-channel";
					dma-channels = <0x1>;
					interrupts = <0 90 4>;
					xlnx,datawidth = <0x80>;
					xlnx,device-id = <0x1>;
				};
			};
		};
	};

Here is everything I know about it:

 - Set the "axi_dma0: dma@<address>" to match the address set in the address
   editor for the AXI DMA core.

 - Set the "xlnx,addrwidth" field to match the width of the AXI DMA's address
   lines. In my case, this was 64 bits.

 - Set the first "dma-channel@<address>" to match the address you used in the 
   address editor. Here, my AXI DMA block was at 0xA00300000.

 - Set the second "dma_channel@<address>" to be the same address as above, but
   add 0x30 to it. This is because the registers for the AXI DMA's receive 
   channel are identical to those for the transmit channel, but offset by 0x30
   in the register map.

 - Set the "xlnx,device-id" to be <0x0> for the transmit channel, and <0x1> 
   for the receive channel.

 - Set the "xlnx,datawidth" to be... well, the data width of the AXI DMA's 
   interfaces. In this case, mine were 128 bits wide, giving <0x80>.

 - The interrupts syntax is a TRAVESTY. The first number has to do with 
   sharing or something, the second number is the actual interrup number, and
   the third tells the kernel whether it's edge- or level-sensitive. Anyway,
   you need to set the middle number to match the irq that channel is using.
   For the love of God DO NOT TOUCH the first and third numbers. How do you
   know which interrupt number it is? Well, the irq lines on the Zynq block
   start at interrup 89 and go up by 1 each time. (There is actually more to
   it: the ARM's iterrupt controller has some IRQ's reserved for interrupts 
   from the FPGA fabric. If you look up these numbers, they will actually 
   start at 120. For some reason, and yes this is true, you have to subtract
   31 to get the number you put into the device tree. No, I don't know why.)

 - Please oh please don't touch anything else. I don't know what it does! The
   overlay mechanism is very fragile, and literally almost any other change 
   you make is certain to crash the ARM.

I really hate the state of things, but this is the way it is. You can get more
information on this in the README provided by the axidma driver. No, of course
not from Xilinx! The one from the two Carnegie Melon students. They provided
documentation for the device tree entries needed by Xilinx's driver... they are
nothing short of heroes!

-> Job 4 (informing the axidma driver)

This isn't too too bad:

	fragment@3 {
		target-path = "/";
		overlay3: __overlay__ {
			axidma_chrdev: axidma_chrdev@0 {
				compatible = "xlnx,axidma-chrdev";
				dmas = <&axi_dma_0 0x0 &axi_dma_0 0x1>;
				dma-names = "tx_channel", "rx_channel";
			};
		};
	};

You can pretty much use it as-is. The only reason you would need to change it is
if you were brave enough to modify the fragment block for Xilinx's driver. Notice
that it references some of its entries.

So, put these fragments together, and this is your .dtsi file. Good luck!

-> Compiling the .dtso

To compile dtsi into dtso, you will need the device tree compiler. Most Linux
distros have a "dtc" package in their official repos.

$ dtc -O dtb -o my_output.dtbo -b 0 -@ my_thing.dtsi



ACTUALLY PROGRAMMING THE FPGA 
-----------------------------

You need a lot of stuff in place for this to work. For starters, Clark's Linux
setup should have all the necessary drivers for PCAP (PCAP is the name given to
the hardened circuit in the PS which is used for reprogramming the FPGA fabric).
It should also include Xilinx's AXI DMA driver. Also, Camilo has written some 
bash commands which you will need. They are in the helpful_bash_stuff folder

In order to program the FPGA (with support for the PS to PL communication), you
will need to perform the following steps:

1. Insert the axidma.ko module, if it hasn't been done already. There is a copy
of it in /home/savi/drivers/axidma.ko (This module was built from the repo at
https://github.com/bperez77/xilinx_axidma)

2. Copy your .bin and .dtbo files into /lib/firmware. I don't really know why
we have to do this; I guess something about the device tree and search paths or
something...

3. After doing a sudo su, issue the set clocks command as: 

$ set_clocks freq1 [freq2] [freq3] [freq4] 

to match the CPU outputs clock frequencies you set in
your block diagram. I don't know why you need to do this; shouldn't the device
tree take care of this?

4. Navigate to /lib/firmware and install the device tree overlay:

$ overlay_reprogram my_overlay.dtbo

5. (I don't think you need to do this; shouldn't the device tree stuff take
care of it?) Upload the bitstream with program my_bitstream.bin

6. (Optional) Verify that the axidma driver recognized your stuff. It'll say
something like "1 transmit and 1 receive channel found" in dmesg.



USING ILAS
----------

Again, I am assuming you are using the system that Clark has put in place. It 
should contain a program called "xvcserver", which I think is a modified version
of the program at https://github.com/tmbinc/xvcd, or maybe the one at 
https://github.com/Xilinx/XilinxVirtualCable. Honestly, I don't know where he 
got it. And by the way, I'm pretty sure it needs a driver in the kernel, too. So
that's another thing that Clark has set up.

Anyway, to use ILAs, you need to do the following:

1) Add a "debug bridge" IP to your design. Set it up in "AXI to BSCAN" mode, and
   hook it up to the PS's AXI bus. For these instructions, I will assume you 
   mapped it to address 0xA0010000
   
2) For the love of all things holy save your .ltx file (vivadoproj/runs/impl_1/)
   somewhere alongside your bitstream. If not, then you will have a random 
   bistream with ILAs you can't use.
   
3) After programming the FPGA, run this command from inside the MPSoC:

$ xvcserver -a 0xA0010000 -d

   This will start the XVC server on the MPSoC.
   
4) Use ssh to tunnel port 2542 from the MPSoC to whatever port you want on your
   local computer. You can do this from inside a running SSH session by hitting
   enter, then typing the ~ key, and hitting a capital C. This will open a neat
   little command line for addign tunnels. Alternatively, you could exit your 
   SSH session and restart with the -L 2542:localhost:2542 switch, as usual

5) Inside Vivado's hardware manager, do "open new target...". Connect to local
   server, and click "Add Xilinx Virtual Cable". Use localhost and whatever port
   you picked for the tunnel (I normally use 2542).

6) Make sure you ask Vivado to use the correct LTX file. I hope you saved it! 
   Because if you made a new bitstream, then the new LTX file has overwritten
   the old one, and you are straight outta luck!



PS TO PL COMMUNICATION
----------------------

This is a little complicated. Here is a summary of the many moving parts:

 - The AXI DMA IP core: 
