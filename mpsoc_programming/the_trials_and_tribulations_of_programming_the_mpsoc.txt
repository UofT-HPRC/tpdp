One does not simply upload a bitstream.

The steps to reprogramming the MPSoC are frustratingly convoluted, and 
depend on many things being in place. This file is meant to help you 
deal with that.

Still though: prepare for great pain and suffering.

=====
TL;DR
=====

The list of commands I end up using:

-> On my computer
$ bootgen -arch zynqmp -image specific.bif -o my_output.bin -w
$ dtc -O dtb -o my_output.dtbo -b 0 -@ my_thing.dtsi
$ scp ...

-> On the MPSoC (if not done already)
$ sudo insmod /path/to/axidma.ko
$ sudo insmod /path/to/mpsoc_axiregs.ko
$ sudo insmod /path/to/mpsoc_PSRegs.ko
$ mountoverlay

-> On the MPSoC (done every time I have a new bitstream)
$ cp my.bin /lib/firmware/whateveriputinthedevicetree.bin
$ cp my.dtbo /lib/firmware/my.dtbo
$ set_clocks freq1 [freq2] [freq3] [freq4] 
$ cd /lib/firmware
$ overlay_reprogram my.dtbo

========
OVERVIEW 
========

First, you need to make sure your MPSoC is running Linux in the exact way Clark
set it up. From now on, I will make this assumption. I do not know how to get
this system working, but I do know it includes:

 - The drivers that apply device tree overlays
 
 - The drivers that allow reprogramming the FPGA
   
 - The drivers used for setting the PS's output clocks (mpsoc_PSRegs.ko)
 
 - The mpsoc_axiregs.ko driver
 
 - (Optional) The XVC server, which allows remote access to ILAs
 

And if you plan to use the PS to PL communication...

 - Linux kernel support for AXI DMA IP cores. This is provided by Xilinx.
   It DOES NOT make device files, it only allows /other kernel code/ to 
   use the DMA core. I call this the "Xilinx AXI DMA kernel API"
   
 - axidma.ko: a driver that uses the Xilinx AXI DMA kernel API and 
   makes the device files you can use from userspace. It was made by 
   Brandon Perez and Jared Choi (not Xilinx). It is extremely good, and 
   these guys actually documented a lot of the arcane wizardry needed 
   to use the Xilinx stuff
   
 - (Optional) Some usermode libraries that provide an API on top of the 
   axidma driver.

Programming the FPGA requires a .bin file (see next section) and a 
.dtbo file ("Device Tree Acrobatics" section).

Once you have these two files, there are several steps to putting them 
in the FPGA. See "Actually programming the FPGA".

I've also added quick sections on using ILAs and PS-to-PL 
communication, but this is just for completeness. Camilo has written 
much better tutorials, which you can find on the main page of our wiki.

Good luck!

=====================
GETTING THE .BIN FILE 
=====================

I don't know why, but the code in the Linux kernel needs the bitstream 
to be in a ".bin" format in order to reprogram the FPGA. Apparently, 
.bin files are nothing more than address-data pairs.

Anyway, making the .bin file just takes a single command: (Make sure to 
source the settings64.sh shell script in your Vivado install)

$ bootgen -arch zynqmp -image specific.bif -o my_output.bin -w

The bootgen command is used for a lot of things, and it expects a file 
with special syntax to tell it what to do (a .bif file). In the case of 
simply making a .bin, the specific.bif file you need is as follows:

	all: 
	{ 
		[destination_device = pl] my_bitstream.bit 
	}

Make sure my_bitstream.bit is in the same folder as the specific.bif 
file.


======================
DEVICE TREE ACROBATICS 
======================

You also need to make a "device tree overlay". This involves writing a 
file in a special language, then compiling it to a special binary file 
the Linux kernel will understand. Writing the overlay is EXTREMELY 
DIFFICULT; I have done my best to explain what I know about it.

Compiling the file is easy, but you need to have the device tree 
compiler installed. Most Linux distributions have a "dtc" package in 
their official repos.


    WHEN CAN YOU AVOID DEVICE TREES? 
    --------------------------------
    Basically, if all you need is access to a few registers, then you just need 
    the bin file. Follow the directions in ps_to_pl/simple_register_accesses.txt
    
    Skip over this entire section, and skip any device-tree related 
    instructions in the "Actually programming the FPGA" section.

Background on device trees and device tree overlays
---------------------------------------------------

"Device trees" is the name given to a technique introduced by 
OpenFirmware. At boot time, you give the Linux kernel a "device tree" 
file (kind of looks like XML) with info about the hardware in your 
system. For regular embedded systems, this file is used once and it is 
assumed that no further hardware changes will occur.

If you are reprogramming an FPGA, then hardware _is_ changing. Instead 
of rebooting, you can use "device tree overlays": at runtime, you ask 
the Linux kernel to read in a .dtbo file, which "patches" the device 
tree that was loaded at boot. This patch will trigger actions inside 
the kernel, such as loading/unloading drivers, and in our case, it also 
causes the FPGA to be reprogrammed.

Makign a dtbo involves writing a dtsi file and compiling it. Coding up 
the dtsi is EXTREMELY DIFFICULT; I have done my best to explain what I 
know about it. Compiling the dtbo is easy; you just to have the device 
tree compiler installed. Most Linux distributions have a "dtc" package 
in their official repos.

	Something you should know: the whole device tree method is still 
	immature. The overlay method is essentially still in beta. People 
	are working on it, but it's a huge and complicated thing that 
	touches a lot of kernel code, so it's slow progress.


Writing the device tree overlay (dtsi)
--------------------------------------

	UPDATE: I finally clued in to what Camilo has been telling me for 
	weeks: you don't write the device tree overlays manually. Check out 
	this git repo:
	
	https://github.com/Xilinx/device-tree-xlnx
	
	I don't know the specifics, but this takes an HDF (From inside a 
	Vivado project: File->Export->Export Hardware...) and automatically 
	generates a dtsi. HOWEVER: apparently it is very broken, and you 
	often need to manually edit the generated file

The syntax for device trees is already bad, but the syntax for overlays 
is far, far worse. At this point, I will encourage you to give up 
understanding it. For starters, unless you wrote your own driver, there 
is LITERALLY NO WAY for you to figure out how to write device tree 
entries for it (the driver writer must provide this info to you). Also, 
the dtsi syntax is very likely to change several times in the next few 
years, so there's really no point learning it until it's more stable.

Our device tree overlay has to accomplish four jobs:

1) Upload the bitstream (in the .bin format) to the FPGA 

2) Set the frequency of the PS's output clocks in the PL (i.e. the ones 
   you set on the Zynq block in your block diagram).  
   
3) (If using PS to PL) Tell Xilinx's DMA driver about AXI DMA cores in 
   your design.  
   
4) (If using PS to PL) Tell the axidma driver about the AXI DMA cores 
   in your design

The general format of the dtsi file is something like:

	/dts-v1/;
	/plugin/;
	/ {
		fragment@0 {
			target = <&some_target>;
			overlay0: __overlay__ {
				/* Specific stuff for some_target */
			};
		};

		fragment@1 {
			target = <&some_other_target>;
			overlay0: __overlay__ {
				/* Specific stuff for some_other_target */
			};
		};

		/* etc... */
	};

Each one of the four jobs we need to do is performed in a separate 
"fragment and overlay" block.

-> Jobs 1 and 2

Luckily, these aren't too difficult. LEAVE EVERYTHING AS-IS, except the 
reference to your bitstream and the clock frequencies

	fragment@0 {
		target = <&fpga_full>;
		overlay0: __overlay__ {
			#address-cells = <2>;
			#size-cells = <2>;
			firmware-name = "my_bistream.bin";
			resets = <&rst 116>;
		};
	};
	fragment@1 {
		target = <&fclk0>;
		overlay1: __overlay__ {
			status = "okay";
			#clock-cells = <0>;
			clock-frequency = <99999001>;
			compatible = "fixed-clock";
		};
	};

This expects "mybitstream.bin" to be inside the "lib/firmware" folder.

I don't know this for sure, but if you have more than one output clock, 
you need to put them in separate fragment blocks. Make sure to increase 
the fragment and overlay indices as you go.

-> Job 3 (Informing Xilinx's driver about AXI DMA cores)

This is by far the most hideous thing I've ever seen. Here is the code 
I've been using:

	fragment@2 {
		target = <&amba>;
		overlay2: __overlay__ {
			axi_dma_0: dma@a0030000 {
				#dma-cells = <1>;
				clock-names = "s_axi_lite_aclk", "m_axi_sg_aclk", "m_axi_mm2s_aclk", "m_axi_s2mm_aclk";
				clocks = <&fclk0>, <&fclk0>, <&fclk0>, <&fclk0>;
				compatible = "xlnx,axi-dma-1.00.a";
				interrupt-names = "mm2s_introut", "s2mm_introut";
				interrupt-parent = <&gic>;
				interrupts = <0 89 4 0 90 4>;
				reg = <0x0 0xa0030000 0x0 0x10000>;
				xlnx,addrwidth = <0x40>;
				xlnx,include-sg ;
				dma-channel@a0030000 {
					compatible = "xlnx,axi-dma-mm2s-channel";
					dma-channels = <0x1>;
					interrupts = <0 89 4>;
					xlnx,datawidth = <0x80>;
					xlnx,device-id = <0x0>;
				};
				dma-channel@a0030030 {
					compatible = "xlnx,axi-dma-s2mm-channel";
					dma-channels = <0x1>;
					interrupts = <0 90 4>;
					xlnx,datawidth = <0x80>;
					xlnx,device-id = <0x1>;
				};
			};
		};
	};

Here is everything I know about it:

 - Set the "axi_dma0: dma@<address>" to match the address set in the 
   address editor for the AXI DMA core.

 - Set the "xlnx,addrwidth" field to match the width of the AXI DMA's 
   address lines. In my case, this was 64 bits.

 - Set the first "dma-channel@<address>" to match the address you used 
   in the address editor. Here, my AXI DMA block was at 0xA00300000.

 - Set the second "dma_channel@<address>" to be the same address as
   above, but add 0x30 to it. This is because the registers for the AXI 
   DMA's receive channel are identical to those for the transmit 
   channel, but offset by 0x30 in the register map.

 - Set the "xlnx,device-id" to be <0x0> for the transmit channel, and 
   <0x1> for the receive channel.

 - Set the "xlnx,datawidth" to be... well, the data width of the AXI 
   DMA's interfaces. In this case, mine were 128 bits wide, giving 
   <0x80>.

 - The interrupts syntax is a TRAVESTY. The first number has to do with 
   sharing or something, the second number is the actual interrupt 
   number, and the third tells the kernel whether it's edge- or 
   level-sensitive.
   
   Anyway, you need to set the middle number to match the IRQ that the
   channel is using. For the love of God DO NOT TOUCH the first and 
   third numbers.
   
   How do you know which interrupt number it is? Well, the IRQ lines on 
   the Zynq block start at interrup 89 and go up by 1 each time. 
   
	  (There is actually more to it: the ARM's interrupt controller has 
	  some IRQ's reserved for interrupts from the FPGA fabric. If you 
	  look up these numbers, they will actually start at 121. For some 
	  reason, and yes this is true, you have to subtract 32 to get the 
	  number you put into the device tree. No, I don't know why.)
    
    More info: http://billauer.co.il/blog/2012/08/irq-zynq-dts-cortex-a9/

 - Please oh please don't touch anything else. I don't know what it 
   does! The overlay mechanism is very fragile, and literally almost 
   any other change you make is certain to crash the ARM.

I really hate the state of things, but this is the way it is. You can 
get more information on this in the README provided by the axidma 
driver. No, of course not from Xilinx! The one from the two Carnegie 
Melon students. They provided documentation for the device tree entries 
needed by Xilinx's driver... they are nothing short of heroes!

-> Job 4 (informing the axidma driver)

This isn't too too bad:

	fragment@3 {
		target-path = "/";
		overlay3: __overlay__ {
			axidma_chrdev: axidma_chrdev@0 {
				compatible = "xlnx,axidma-chrdev";
				dmas = <&axi_dma_0 0x0 &axi_dma_0 0x1>;
				dma-names = "tx_channel", "rx_channel";
			};
		};
	};

You can pretty much use it as-is. The only reason you would need to change it is
if you were brave enough to modify the fragment block for Xilinx's driver. Notice
that it references some of its entries.

So, put these fragments together, and this is your .dtsi file. Good luck!


Compiling the .dtbo
-------------------

To compile dtsi into dtbo, you will need the device tree compiler. Most Linux
distros have a "dtc" package in their official repos.

$ dtc -O dtb -o my_output.dtbo -b 0 -@ my_thing.dtsi


=============================
ACTUALLY PROGRAMMING THE FPGA 
=============================

    IF YOU SKIPPED THE DEVICE TREES:
    Any of the instructions marked with a [*] should be skipped here.


PREREQUISITES
-------------

(Note: you don't have to read this; it's more of a checklist for when you're 
troubleshooting)

The following infrastructure should already be installed on the MPSoCs: 

    - Clark's Linux setup should have all the necessary drivers for PCAP 
      (PCAP is the name given to the hardened circuit in the PS which is 
      used for programming the FPGA fabric).
      
    - <*> Mount the configfs filesystem (needed for applying device tree 
      overlays)

    - Clark and Camilo have created some bash commands which you will need. 
      These commands are in /root/.bash_aliases
            
      For reference, I have provided this file in
        
        helpful_scripts/mpsoc_bash_stuff/clarks_aliases
      
      Notice that there are three variations: clarks_aliases, camilos_aliases, 
      and marcos_aliases. They all do the same thing, just with different inner 
      workings. I have used Camilo's and my own aliases file with no problems, 
      but it's probably safest to use Clark's.
      
    - If using Camilo's aliases, you need /root/disablePci.sh. I have provided 
      this file in helpful_scripts/mpsoc_bash_stuff
      
    - (If using PS to PL) Xilinx's AXI DMA kernel API (included in the 
      kernel) 

    - (If using PS to PL) The axidma.ko driver (which should be somewhere 
      in the home folder)


INSTRUCTIONS
-------------

In order to program the FPGA, you will need to perform the following steps:

1. (If using PS to PL) Insert the axidma.ko module, if it hasn't been 
   done already. There is a copy of it in /home/savi/drivers/axidma.ko 
   This module was built from the EXCELLENT repo at:
   
   https://github.com/bperez77/xilinx_axidma

2. Check if configfs is mounted. Basically, there should be a folder 
   called /configfs with some device tree stuff in it. If not, run:

   $ mountoverlay
   
   (You don't need to do this step if you use clark's or my aliases 
   file)

3. Copy your .bin file into /lib/firmware. If you have a .dtbo from making a 
   device tree, copy that too. You must do this, since only this folder is 
   searched when programming the bitstream.
   
   $ cp my.bin /lib/firmware/my.bin
[*]$ cp my.dtbo /lib/firmware/my.dtbo

4. After doing a sudo su, issue the set clocks command as: 

   $ set_clocks freq1 [freq2] [freq3] [freq4] 

   to match the CPU outputs clock frequencies you set in your block diagram. 
   The frequencies should be given in MHz, and you can safely round to the 
   nearest integer
   
	  NOTE: This is something the mpsoc_PSegs driver could take care of 
	  automatically, but I am still working on it

5. ONLY if you DID NOT make a device tree, simply run:

   $ sudo su
   $ program my.bin
   
   You can run this command from any folder, but please note that it will ONLY 
   search for the file "my.bin" in the "/lib/firmware" folder. It WILL NOT 
   search your current folder!
   
   [*] If, instead, you did make a device tree, perform:
   
   $ sudo su
   $ overlay_reprogram my_overlay.dtbo

   Similarly to the program command, this command only searches /lib/firmware

6. (If using PS-to-PL) Verify that the axidma driver recognized your stuff. 
   It'll say something like "1 transmit and 1 receive channel found" in 
   dmesg.


==========
USING ILAS
==========

(This is a quick-and-dirty reference. A more full description can be 
found on our wiki.)

Again, I am assuming you are using the system that Clark has put in place. It 
should contain a program called "xvcserver". I have provided the source code 
for this program in mpsoc_programming/xvc_server. See that directory for more 
info.

Anyway, to use ILAs, you need to do the following:

1) Add a "debug bridge" IP to your design. Set it up in "AXI to BSCAN" 
   mode, and hook it up to the PS's AXI bus. For these instructions, I 
   will assume you mapped it to address 0xA0010000
   
2) For the love of all things holy save your .ltx file 
   (vivadoproj/runs/impl_1/thing.ltx) somewhere alongside your bitstream. If 
   not, then you will have a random bitstream with ILAs you can't use.
   
3) After programming the FPGA, run this command from inside the MPSoC:

   $ xvcserver -a 0xA0010000 -d

   This will start the XVC server on the MPSoC. Again, replace 0xA0010000 with 
   the debug bridge's base address in the address editor.
   
4) Use ssh to tunnel port 2542 from the MPSoC to whatever port you want 
   on your local computer. You can do this from inside a running SSH 
   session by hitting enter, then typing the ~ key, and hitting a 
   capital C. This will open a neat little command line for adding 
   tunnels. Alternatively, you could exit your SSH session and restart 
   with the -L 2542:localhost:2542 switch, as usual

5) Inside Vivado's hardware manager, do "open new target...". Connect 
   to local server, and click "Add Xilinx Virtual Cable". Use localhost 
   and whatever port you picked for the tunnel (I normally use 2542).

6) Make sure you ask Vivado to use the correct LTX file. I hope you 
   saved it! Because if you made a new bitstream, then the new LTX file 
   has overwritten the old one, and you are straight outta luck!


======================
PS TO PL COMMUNICATION
======================

(This is a quick-and-dirty reference. A more full description can be 
found on our wiki, and in mpsoc_programming/ps_to_pl)

This is a little complicated. Here is a summary of the many moving 
parts:

 - The AXI DMA IP core: this is something you add to your FPGA design. 
   It will plug into the Zynq block. Setting its parameters is 
   complicated, and I don't know all the details yet
   
 - The Xilinx AXI DMA kernel API: this allows the kernel to access the 
   IP core
  
 - The DMAEngine system: this is an API used by Linux kernel code. It 
   is not accessible by user space code. The purpose of the Xilinx AXI 
   DMA kernal API is to register some stuff into the DMAEngine system so 
   that calls to the DMAEngine API (by other drivers) can eventually 
   trigger the AXI DMA IP core
 
 - The axidma driver: this is the driver written by the Carnegie Melon 
   students. It uses the DMAEngine API and creates device files that 
   you can use from user space
 
 - The axidma user API library: this is a user mode shared library that 
   makes it a little easier to use the axidma driver. It essentially 
   converts the low level details of reading/writing from the driver 
   into a nice-ish API.
 
 - The device tree. Without a correct device tree, the Xilinx driver 
   and axidma driver will not correctly detect the hardware.

At the moment I don't know the details of setting up the IP core, and 
I'm not really familiar with the axidma API library. And by the way, 
I'm pretty sure Clark and Camilo modified the axidma API library so 
that it also works with the MPSoC drivers that Clark wrote (see 
MPSoC_sources/drivers)
